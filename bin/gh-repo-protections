#!/usr/bin/env python


import argparse
import json
import sys
from typing import Optional, Union

import requests

from github_api_client import utilities


SCRIPT_NAME = 'gh-repo-protection'

def stderr(*args):
    print(*args, file=sys.stderr)

REPO_PROPERTIES = [
    'full_name',
    'allow_merge_commit',
    'allow_rebase_merge',
    'allow_squash_merge',
    'private',
    'fork',
    'forks_count',
    'default_branch',
    'open_issues_count',
    'is_template',
    'has_issues',
    'has_projects',
    'has_wiki',
    'has_pages',
    'has_downloads',
    'archived',
    'disabled',
    'visibility',
    'pushed_at',
    'updated_at',
    'created_at',
    'template_repository'
]


class RepoAnalyzer:
    def __init__(self) -> None:
        self.repos = []

    def consider_repos(
          self: object,
          org: Optional[str] = None,
          user: Optional[str] = None,
          repo: Optional[str] = None
      ) -> None:
        if org is not None:
            repos_path = f"orgs/{org}/repos"
        elif user is not None:
            repos_path = f"users/{user}/repos"
        else:
            raise Exception(
                'In `consider_repos` an org or user must be provided'
            )
        if repo is not None:
            self.consider_repo(f"{org or user}/{repo}")
            return
        repos = utilities.collect_resource(repos_path)
        for repo in [repo['name'] for repo in repos]:
            self.consider_repo(f"{org or user}/{repo}")

    def consider_repo(self, path: str) -> None:
        stderr(f"Considering {path}")
        repo_path = f"repos/{path}"
        repo_response = utilities.api(repo_path)
        if repo_response.status_code != 200:
            stderr(f"Failed to retrieve repository {path} "
                   f"with {repo_response.status_code}: "
                   f"{repo_response.json()}")
        repo_info = dict([
            (prop, repo_response.json().get(prop))
            for prop in REPO_PROPERTIES
        ])

        branches_path = f"{repo_path}/branches"
        branches_response = utilities.api(branches_path)
        if branches_response.status_code != 200:
            stderr(f"Failed to retrieve branches for {path} "
                   f"with {branches_response.status_code}:"
                   f"{branches_response.json()}")
        repo_info['branches'] = []
        for branch in branches_response.json():
            branch_info = dict([
                (prop, branch[prop]) for prop in ['name', 'protected']
            ])
            if branch['protected'] is True:
                branch_path = f"{branches_path}/{branch['name']}/protection"
                branch_response = utilities.api(branch_path)
                if branch_response.status_code != 200:
                    stderr(
                        f"Failed to retrieve branch protections for "
                        f"{path}:{branch['name']} "
                        f"with {branch_response.status_code}: "
                        f"{branch_response.json()}"
                    )
                    continue
                branch_info = {**branch_info, **branch_response.json()}
                del branch_info['url']
                for key in [
                      'enforce_admins',
                      'required_pull_request_reviews',
                      'required_signatures',
                      'required_status_checks'
                  ]:
                    if key in branch_info:
                        del branch_info[key]['url']
            repo_info['branches'].append(branch_info)
        self.repos.append(repo_info)

    def __str__(self):
        return json.dumps(self.repos)


def get_argparser(name: str) -> argparse.Namespace:
    parser = argparse.ArgumentParser(name)
    parser.add_argument('-r', '--repository', required=False)
    parser.add_argument('-o', '--organization', required=False)
    parser.add_argument('-u', '--user', required=False)
    return parser


def main(args: list) -> None:
    argparser = get_argparser(SCRIPT_NAME)
    parsed_args = argparser.parse_args(args)

    if not (parsed_args.organization or parsed_args.user):
        argparser.print_help()
        argparser.exit(1, '\nEither an organization or a user must be specified\n')

    analyzer = RepoAnalyzer()
    analyzer.consider_repos(
        org=parsed_args.organization,
        user=parsed_args.user,
        repo=parsed_args.repository
    )
    print(analyzer)


if __name__ == '__main__':
    main(sys.argv[1:])
